;******* Main
;*****************************
main:    CALL    init  
loop:    LDA     0,i         ;
         CHARI   command,d
         LDBYTEA command,d   ;
         CPA     'q',i       ;
         BRNE    decoder     ;
         CALL    fin         ;
decoder: CPA     'd',i       ;
         BRNE    traduire    ;
         CALL    decode      ;
traduire:CPA     't',i       ;
         BRNE    ajoute      ;
         CALL    translt     ;
ajoute:  CPA     'a',i       ;
         BRNE    lister      ;
         ;call addRule()
lister:  CPA     'l',i       ;
         BRNE    cata        ;
         ;call lister()      ;
cata:    CPA     'c',i       ;
         BRNE    loop        ;
         ;call  catalog()    ;
         BR      loop        ;
          
command: .BLOCK 1            ;#1c       
;******** Initialisation 
;*****************************
init:    LDA     mLength,i   
         CALL    new         ;#carac #dotNext #lineNext #before
         LDA     0,i   
         STA     dotNext,x
         STA     lineNext,x     
         STBYTEA carac,x     
         STX     begin,d     
         STX     head,d   
;  Noeud 'E' 
         LDA     mLength,i   
         CALL    new         ;#carac #dotNext #lineNext #before
         LDA     0,i   
         STA     dotNext,x
         STA     lineNext,x       
         LDBYTEA 'E',i       
         STBYTEA carac,x     
         LDA     head,d      
         STA     before,x    
         STX     head,d      
         LDX     before,x    
         LDA     head,d      
         STA     dotNext,x   
;  Noeud '0'
         LDX     dotNext,x   
         LDA     mLength,i   
         CALL    new         ;#carac #dotNext #lineNext #before
         LDA     0,i    
         STA     dotNext,x
         STA     lineNext,x     
         STBYTEA carac,x     
         LDA     head,d      
         STA     before,x    
         STX     head,d      
         LDX     before,x    
         LDA     head,d      
         STA     dotNext,x  
;  Noeud 'S'
         LDX     dotNext,x   
         LDA     mLength,i   
         CALL    new         ;#carac #dotNext #lineNext #before
         LDA     0,i         
         STA     dotNext,x
         STA     lineNext,x 
         LDBYTEA 'S',i       
         STBYTEA carac,x     
         LDA     head,d      
         STA     before,x    
         STX     head,d      
         LDX     before,x    
         LDA     head,d      
         STA     dotNext,x  
 ; Noeud 'T'
         LDX     begin,d     
         LDA     mLength,i   
         CALL    new         ;#carac #dotNext #lineNext #before
         LDA     0,i        
         STA     dotNext,x
         STA     lineNext,x  
         LDBYTEA 'T',i       
         STBYTEA carac,x     
         LDA     begin,d      
         STA     before,x    
         STX     head,d      
         LDX     before,x    
         LDA     head,d      
         STA     lineNext,x  
; Noeud '0'
         LDX     lineNext,x  
         LDA     mLength,i   
         CALL    new         ;#carac #dotNext #lineNext #before
         LDA     0,i         
         STA     dotNext,x
         STA     lineNext,x       
         STBYTEA carac,x     
         LDA     head,d      
         STA     before,x    
         STX     head,d      
         LDX     before,x    
         LDA     head,d      
         STA     lineNext,x   
; Noeud 'O'
         LDX     lineNext,x  
         LDA     mLength,i   
         CALL    new         ;#carac #dotNext #lineNext #before
         LDA     0,i        
         STA     dotNext,x
         STA     lineNext,x  
         LDBYTEA 'O',i       
         STBYTEA carac,x     
         LDA     head,d      
         STA     before,x    
         STX     head,d      
         LDX     before,x    
         LDA     head,d      
         STA     lineNext,x  
         ret0 
;***** Methode decode
;*****************************
decode:  LDX     begin,d     ; X = begin
loopDe:  LDA     0,i         ; while(signe != '\n'){
         CHARI   signe,d     ;    signe = lireChar
         LDBYTEA signe,d     ;
         CPA     '\n',i      ; 
         BREQ    outDecod    ;
         CPA     '.',i       ;    
         BRNE    lineDe      ;    if(signe == '.'){
         LDA     dotNext,x   ;
         CPA     0,i         ;
         BREQ    nopDecod    ;        if(X.dotNext != null){
         LDX     dotNext,x   ;            X = X.dotNext }
         BR      loopDe      ;    }
lineDe:  CPA     '-',i       ;    
         BRNE    outDecod    ;    if(signe == '-'){
         LDA     lineNext,x  ;
         CPA     0,i         ;
         BREQ    nopDecod    ;        if(X.lineNext != null){
         LDX     lineNext,x  ;            X = X.lineNext }
         BR      loopDe      ;    }
outDecod:LDA     0,i         ;
         LDBYTEA carac,x     ;    A = X.carac
         CPA     0,i         ;
         BRNE    Decode      ;    
nopDecod:STRO    nopDe,d     ;        afficher("nop")
         BR      endDecod    ;    }else{
Decode:  CHARO   carac,x     ;        afficher(X.carac)}
endDecod:CHARO   '\n',i      ;    afficher('\n')
         ret0                ;}
;
nopDe:   .ASCII "nop\x00"
;*****************************
;******* Methode translate
;*****************************
translt: LDX     begin,d     ;
         LDA     0,i         ;
         STA     nopTrs,d    ;
loopTrs: LDA     0,i         ;
         CHARI   signe,d     ;
         LDBYTEA signe,d     ;
         CPA     '\n',i      ;
         BREQ    endTrans    ;
         CPA     ' ',i       ;
         BREQ    outTrans    ;
         CPA     '.',i       ;
         BRNE    lineTran    ;
         LDA     dotNext,x   ;
         CPA     0,i         ;
         BREQ    nopTrans    ;
         LDX     dotNext,x   ;
lineTran:CPA     '-',i       ;
         BRNE    loopTrs     ;
         LDA     lineNext,x  ;
         CPA     0,i         ;
         BREQ    nopTrans    ;
         LDX     lineNext,x  ;
         BR      loopTrs     ;

nopTrans:LDA     1,i         ;
         STA     nopTrs,d    ;
         BR      loopTrs     ;

endTrans:LDA     1,i         ;
         STA     endTrs,d    ; 

outTrans:LDA     0,i         ;
         LDBYTEA carac,x     ;
         CPA     0,i         ;
         BRNE    decodTrs    ;

rienTrs: STRO    nopTr,d     ;
         BR      finiTrs     ;        
decodTrs:LDA     nopTrs,d    ;
         CPA     0,i         ;
         BRNE    rienTrs     ;
         CHARO   carac,x     ;

finiTrs: LDA     endTrs,n    ;
         CPA     0,i         ;
         BREQ    translt     ;
         CHARO   '\n',i      ;
         ret0                ;

nopTr:   .ASCII "?\x00"
endTrs:  .EQUATE 0
nopTrs:  .BLOCK  2

fin:     STOP        
;*****************************        
begin:   .BLOCK  2           ; #2h debut de liste
head:    .BLOCK  2           ; #2h tÃªte de liste
signe:   .BLOCK  1           ;#1c
;
;****** structure du noeud
;*****************************
carac:   .EQUATE 0           ;#1c
dotNext: .EQUATE 1           ;#2h
lineNext:.EQUATE 3           ;#2h
before:  .EQUATE 5           ;#2h
mLength: .EQUATE 7           ;taille d'un noeud
;******* operator new
; Precondition: A contains number of bytes
; Postcondition: X contains pointer to bytes
new:     LDX     hpPtr,d     ;returned pointer
         ADDA    hpPtr,d     ;allocate from heap
         STA     hpPtr,d     ;update hpPtr
         RET0                
hpPtr:   .ADDRSS heap        ;address of next free byte
heap:    .BLOCK  1           ;first byte in the heap
         .END                  
