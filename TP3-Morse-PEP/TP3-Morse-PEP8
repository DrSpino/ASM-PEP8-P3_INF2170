;******* Main
;*****************************
main:    CALL    init  
loop:    LDA     0,i         ;
         CHARI   command,d
         LDBYTEA command,d   ;
         CPA     'q',i       ;
         BRNE    decoder     ;
         CALL    fin         ;
decoder: CPA     'd',i       ;
         BRNE    traduire    ;
         CALL    decode      ;
traduire:CPA     't',i       ;
         BRNE    ajoute      ;
         CALL    translt     ;
ajoute:  CPA     'a',i       ;
         BRNE    lister      ;
         CALL    addRule     ;
lister:  CPA     'l',i       ;
         BRNE    cata        ;
         CALL    list        ;
         STRO    stTotal,d   ;
         DECO    total,d     ;
         CHARO   '\n',i      ;
cata:    CPA     'c',i       ;
         BRNE    loop        ;
         CALL    catalog     ;
         BR      loop        ;

stTotal: .ASCII "total=\x00" ;          
command: .BLOCK 1            ;#1c       
;******** Initialisation 
;*****************************
init:    LDA     mLength,i   
         CALL    new         ;#carac #dotNext #lineNext #before
         LDA     0,i   
         STA     dotNext,x
         STA     lineNext,x  
         STA     before,x   
         STBYTEA carac,x     
         STX     begin,d     
         STX     head,d   
;  Noeud 'E' 
         LDA     mLength,i   
         CALL    new         ;#carac #dotNext #lineNext #before
         LDA     0,i   
         STA     dotNext,x
         STA     lineNext,x       
         LDBYTEA 'E',i       
         STBYTEA carac,x     
         LDA     head,d      
         STA     before,x    
         STX     head,d      
         LDX     before,x    
         LDA     head,d      
         STA     dotNext,x   
;  Noeud '0'
         LDX     dotNext,x   
         LDA     mLength,i   
         CALL    new         ;#carac #dotNext #lineNext #before
         LDA     0,i    
         STA     dotNext,x
         STA     lineNext,x     
         STBYTEA carac,x     
         LDA     head,d      
         STA     before,x    
         STX     head,d      
         LDX     before,x    
         LDA     head,d      
         STA     dotNext,x  
;  Noeud 'S'
         LDX     dotNext,x   
         LDA     mLength,i   
         CALL    new         ;#carac #dotNext #lineNext #before
         LDA     0,i         
         STA     dotNext,x
         STA     lineNext,x 
         LDBYTEA 'S',i       
         STBYTEA carac,x     
         LDA     head,d      
         STA     before,x    
         STX     head,d      
         LDX     before,x    
         LDA     head,d      
         STA     dotNext,x  
 ; Noeud 'T'
         LDX     begin,d     
         LDA     mLength,i   
         CALL    new         ;#carac #dotNext #lineNext #before
         LDA     0,i        
         STA     dotNext,x
         STA     lineNext,x  
         LDBYTEA 'T',i       
         STBYTEA carac,x     
         LDA     begin,d      
         STA     before,x    
         STX     head,d      
         LDX     before,x    
         LDA     head,d      
         STA     lineNext,x  
; Noeud '0'
         LDX     lineNext,x  
         LDA     mLength,i   
         CALL    new         ;#carac #dotNext #lineNext #before
         LDA     0,i         
         STA     dotNext,x
         STA     lineNext,x       
         STBYTEA carac,x     
         LDA     head,d      
         STA     before,x    
         STX     head,d      
         LDX     before,x    
         LDA     head,d      
         STA     lineNext,x   
; Noeud 'O'
         LDX     lineNext,x  
         LDA     mLength,i   
         CALL    new         ;#carac #dotNext #lineNext #before
         LDA     0,i        
         STA     dotNext,x
         STA     lineNext,x  
         LDBYTEA 'O',i       
         STBYTEA carac,x     
         LDA     head,d      
         STA     before,x    
         STX     head,d      
         LDX     before,x    
         LDA     head,d      
         STA     lineNext,x  
         ret0 
;***** Methode decode
;*****************************
decode:  LDX     begin,d     ; X = begin
loopDe:  LDA     0,i         ; while(signe != '\n'){
         CHARI   signe,d     ;    signe = lireChar
         LDBYTEA signe,d     ;
         CPA     '\n',i      ; 
         BREQ    outDecod    ;
         CPA     '.',i       ;    
         BRNE    lineDe      ;    if(signe == '.'){
         LDA     dotNext,x   ;
         CPA     0,i         ;
         BREQ    nopDecod    ;        if(X.dotNext != null){
         LDX     dotNext,x   ;            X = X.dotNext }
         BR      loopDe      ;    }
lineDe:  CPA     '-',i       ;    
         BRNE    outDecod    ;    if(signe == '-'){
         LDA     lineNext,x  ;
         CPA     0,i         ;
         BREQ    nopDecod    ;        if(X.lineNext != null){
         LDX     lineNext,x  ;            X = X.lineNext }
         BR      loopDe      ;    }
outDecod:LDA     0,i         ;
         LDBYTEA carac,x     ;    A = X.carac
         CPA     0,i         ;
         BRNE    Decode      ;    
nopDecod:STRO    nopDe,d     ;        afficher("nop")
         BR      endDecod    ;    }else{
Decode:  CHARO   carac,x     ;        afficher(X.carac)}
endDecod:CHARO   '\n',i      ;    afficher('\n')
         ret0                ;}
;
nopDe:   .ASCII "nop\x00"
;*****************************
;******* Methode translate
;*****************************
translt: LDX     begin,d     ;
         LDA     0,i         ;
         STA     nopTrs,d    ;
         STA     endTrs,d    ;
loopTrs: LDA     0,i         ;
         CHARI   signe,d     ;
         LDBYTEA signe,d     ;
         CPA     '\n',i      ;
         BREQ    endTrans    ;
         CPA     ' ',i       ;
         BREQ    outTrans    ;
         CPA     '.',i       ;
         BRNE    lineTran    ;
         LDA     dotNext,x   ;
         CPA     0,i         ;
         BREQ    nopTrans    ;
         LDX     dotNext,x   ;
lineTran:CPA     '-',i       ;
         BRNE    loopTrs     ;
         LDA     lineNext,x  ;
         CPA     0,i         ;
         BREQ    nopTrans    ;
         LDX     lineNext,x  ;
         BR      loopTrs     ;

nopTrans:LDA     1,i         ;
         STA     nopTrs,d    ;
         BR      loopTrs     ;

endTrans:LDA     1,i         ;
         STA     endTrs,d    ; 

outTrans:LDA     0,i         ;
         LDBYTEA carac,x     ;
         CPA     0,i         ;
         BRNE    decodTrs    ;

rienTrs: STRO    nopTr,d     ;
         BR      finiTrs     ;        
decodTrs:LDA     nopTrs,d    ;
         CPA     0,i         ;
         BRNE    rienTrs     ;
         CHARO   carac,x     ;

finiTrs: LDA     endTrs,d    ;
         CPA     0,i         ;
         BREQ    translt     ;
         CHARO   '\n',i      ;
         ret0                ;

nopTr:   .ASCII "?\x00"      ;
endTrs:  .BLOCK  2           ;
nopTrs:  .BLOCK  2           ;
;*****************************
;******* Methode addRule
;*****************************
addRule: LDX     begin,d     ;
         CHARI   chara,d     ;
loopRule:LDA     0,i         ;
         CHARI   signe,d     ;
         LDBYTEA signe,d     ;
         CPA     '\n',i      ;
         BREQ    endRule     ;
         CPA     ' ',i       ;
         BREQ    endRule     ;
         
         CPA     '.',i       ;
         BRNE    goLine      ;
         LDA     dotNext,x   ;
         CPA     0,i         ;
         BRNE    dotRule     ;
         LDA     mLength,i
         CALL    new         ;#carac #dotNext #lineNext #before
         LDA     0,i         ;
         STA     dotNext,x   ;
         STA     lineNext,x  ;  
         STBYTEA carac,x     ;
         LDA     avant,d     ;
         STA     before,x    ;
         STX     head,d      ;
         LDX     before,x    ;
         LDA     head,d      ;
         STA     dotNext,x   ;
dotRule: LDA     dotNext,x   ;
         STA     avant,d     ;
         LDX     dotNext,x   ;
         BR      loopRule    ;

goLine:  CPA     '-',i       ;
         BRNE    endRule     ;
         LDA     lineNext,x  ;
         CPA     0,i         ;
         BRNE    lineRule    ;
         LDA     mLength,i
         CALL    new         ;#carac #dotNext #lineNext #before
         LDA     0,i         ;
         STA     dotNext,x   ;
         STA     lineNext,x  ;  
         STBYTEA carac,x     ;
         LDA     avant,d     ;
         STA     before,x    ;
         STX     head,d      ;
         LDX     before,x    ;
         LDA     head,d      ;
         STA     lineNext,x  ;   
lineRule:LDA     lineNext,x  ;
         STA     avant,d     ;
         LDX     lineNext,x  ; 
         BR      loopRule    ;      

endRule: LDA     0,i         ;
         LDBYTEA chara,d     ;
         STBYTEA carac,x     ;
         ret0                ;
         
         
chara:   .BLOCK 1            ;#1c
avant:   .BLOCK 2            ;#2h

;*****************************
;******** Methode list
;*****************************
list:    LDX     begin,d
         LDA     0,i
         STA     total,d

listRec: SUBSP   4,i         ;#pDotNext #pLineNext 
         
         LDA     dotNext,x
         STA     pDotNext,s 
         LDA     lineNext,x
         STA     pLineNex,s        
         
         LDA     0,i
         LDBYTEA carac,x
         CPA     0,i
         BREQ    dotList
         CHARO   carac,x
         CHARO   '\n',i 
         LDA     total,d
         ADDA    1,i
         STA     total,d 

dotList: LDA     pDotNext,s
         CPA     0,i
         BREQ    lineList
         LDX     pDotNext,s         
         CALL    listRec

lineList:LDA     pLineNex,s
         CPA     0,i
         BREQ    endList
         LDX     pLineNex,s
         CALL    listRec

endList: ADDSP   4,i         ;#pDotNext #pLineNext
         ret0                ;

;*****************************
;******** Methode catalogue
;*****************************
catalog: LDX     begin,d
         LDA     0,i
         STA     total,d

cataRec: SUBSP   4,i         ;#pDotNext #pLineNext 
         
         LDA     dotNext,x
         STA     pDotNext,s 
         LDA     lineNext,x
         STA     pLineNex,s        
         
         LDA     0,i
         LDBYTEA carac,x
         CPA     0,i
         BREQ    dotcata
         CHARO   carac,x
         
loopCata:LDA     before,x
         CPA     0,i
         BREQ    outCata
         SUBSP   2,i         ;#pileBefo
         LDA     love,n
         STA     pileBefo,s
         LDA     compteur,d
         ADDA    1,i
         STA     compteur,d
         LDX     before,x
         BR      loopCata

outCata: LDX     begin,d
loopOut: LDA     compteur,d
         SUBA    1,i
         CPA     -1,i
         BREQ    returnCa
         
         LDA     pileBefo,s
         CPA     dotNext,x
         BRNE    outLine
         CHARO   '.',i
         BR      loopOut
outLine: CPA     lineNext,x
         BRNE    loopOut
         CHARO   '-',i
         BR      loopOut 
                  

returnCa:CHARO   '\n',i 
         LDA     total,d
         ADDA    1,i
         STA     total,d
 

dotcata: LDA     pDotNext,s
         CPA     0,i
         BREQ    linecata
         LDX     pDotNext,s         
         CALL    cataRec

linecata:LDA     pLineNex,s
         CPA     0,i
         BREQ    endList
         LDX     pLineNex,s
         CALL    cataRec

endcata: ADDSP   4,i         ;#pDotNext #pLineNext
         ret0                ;

compteur:.BLOCK 2            ;#2d

fin:     STOP   
  
;*****************************
pileBefo:.EQUATE 0           ;#2h

pDotNext:.EQUATE 2           ;#2h 
pLineNex:.EQUATE 0           ;#2h   
;*****************************        
total:   .BLOCK  2           ;#2d
begin:   .BLOCK  2           ; #2h debut de liste
head:    .BLOCK  2           ; #2h tête de liste
signe:   .BLOCK  1           ; #1c
;
;****** structure du noeud
;*****************************
love:    .ADDRSS carac       ;#2h
carac:   .EQUATE 0           ;#1c 
dotNext: .EQUATE 1           ;#2h
lineNext:.EQUATE 3           ;#2h
before:  .EQUATE 5           ;#2h
mLength: .EQUATE 7           ;taille d'un noeud
;******* operator new
; Precondition: A contains number of bytes
; Postcondition: X contains pointer to bytes
new:     LDX     hpPtr,d     ;returned pointer
         ADDA    hpPtr,d     ;allocate from heap
         STA     hpPtr,d     ;update hpPtr
         RET0                
hpPtr:   .ADDRSS heap        ;address of next free byte
heap:    .BLOCK  1           ;first byte in the heap
         .END                  
