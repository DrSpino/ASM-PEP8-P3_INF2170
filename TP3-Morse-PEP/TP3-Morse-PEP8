;******* Main
;*****************************
main:    CALL    init        ; call init
loop:    LDA     0,i         ; while (command != 'q'){
         CHARI   command,d   ;    command = lireChar
         LDBYTEA command,d   ;
         CPA     'q',i       ; 
         BRNE    decoder     ; 
         CALL    fin         ;    
decoder: CPA     'd',i       ; 
         BRNE    traduire    ;    }else if(command == 'd'){
         CALL    decode      ;        call decode
traduire:CPA     't',i       ; 
         BRNE    ajoute      ;    }else if(command == 't'){
         CALL    translt     ;        call translt
ajoute:  CPA     'a',i       ; 
         BRNE    lister      ;    }else if(command =='a'){
         CALL    addRule     ;        call addRule
lister:  CPA     'l',i       ;
         BRNE    cata        ;    }else if(command == 'l'){
         LDA     0,i         ;    
         STA     isCata,d    ;        isCata = 0
         CALL    list        ;        call list
         STRO    stTotal,d   ; 
         DECO    total,d     ;
         CHARO   '\n',i      ;        affiche("total ="+total+'\n')
cata:    CPA     'c',i       ;
         BRNE    loop        ;    }else if(command == 'c'){
         LDA     1,i         ;
         STA     isCata,d    ;        isCata = 1
         CALL    list        ;        call list
         STRO    stTotal,d   ;
         DECO    total,d     ;
         CHARO   '\n',i      ;        affiche("total = "+total+"\n")
         BR      loop        ;    }//fin elseif }//fin loop 

stTotal: .ASCII "total=\x00" ;          
command: .BLOCK 1            ;       
;******** Initialisation 
;*****************************
init:    LDA     mLength,i   
         CALL    new         ;#carac #dotNext #lineNext #before
         LDA     0,i   
         STA     dotNext,x
         STA     lineNext,x  
         STA     before,x   
         STBYTEA carac,x     
         STX     begin,d     
         STX     head,d   
;  Noeud 'E' 
         LDA     mLength,i   
         CALL    new         ;#carac #dotNext #lineNext #before
         LDA     0,i   
         STA     dotNext,x
         STA     lineNext,x       
         LDBYTEA 'E',i       
         STBYTEA carac,x     
         LDA     head,d      
         STA     before,x    
         STX     head,d      
         LDX     before,x    
         LDA     head,d      
         STA     dotNext,x   
;  Noeud '0'
         LDX     dotNext,x   
         LDA     mLength,i   
         CALL    new         ;#carac #dotNext #lineNext #before
         LDA     0,i    
         STA     dotNext,x
         STA     lineNext,x     
         STBYTEA carac,x     
         LDA     head,d      
         STA     before,x    
         STX     head,d      
         LDX     before,x    
         LDA     head,d      
         STA     dotNext,x  
;  Noeud 'S'
         LDX     dotNext,x   
         LDA     mLength,i   
         CALL    new         ;#carac #dotNext #lineNext #before
         LDA     0,i         
         STA     dotNext,x
         STA     lineNext,x 
         LDBYTEA 'S',i       
         STBYTEA carac,x     
         LDA     head,d      
         STA     before,x    
         STX     head,d      
         LDX     before,x    
         LDA     head,d      
         STA     dotNext,x  
 ; Noeud 'T'
         LDX     begin,d     
         LDA     mLength,i   
         CALL    new         ;#carac #dotNext #lineNext #before
         LDA     0,i        
         STA     dotNext,x
         STA     lineNext,x  
         LDBYTEA 'T',i       
         STBYTEA carac,x     
         LDA     begin,d      
         STA     before,x    
         STX     head,d      
         LDX     before,x    
         LDA     head,d      
         STA     lineNext,x  
; Noeud '0'
         LDX     lineNext,x  
         LDA     mLength,i   
         CALL    new         ;#carac #dotNext #lineNext #before
         LDA     0,i         
         STA     dotNext,x
         STA     lineNext,x       
         STBYTEA carac,x     
         LDA     head,d      
         STA     before,x    
         STX     head,d      
         LDX     before,x    
         LDA     head,d      
         STA     lineNext,x   
; Noeud 'O'
         LDX     lineNext,x  
         LDA     mLength,i   
         CALL    new         ;#carac #dotNext #lineNext #before
         LDA     0,i        
         STA     dotNext,x
         STA     lineNext,x  
         LDBYTEA 'O',i       
         STBYTEA carac,x     
         LDA     head,d      
         STA     before,x    
         STX     head,d      
         LDX     before,x    
         LDA     head,d      
         STA     lineNext,x  
         ret0 
;***** Methode decode
;*****************************
decode:  LDX     begin,d     ; X = begin
loopDe:  LDA     0,i         ; while(signe != '\n'){
         CHARI   signe,d     ;    signe = lireChar
         LDBYTEA signe,d     ;
         CPA     '\n',i      ; 
         BREQ    outDecod    ;
         CPA     '.',i       ;    
         BRNE    lineDe      ;    if(signe == '.'){
         LDA     dotNext,x   ;
         CPA     0,i         ;
         BREQ    nopDecod    ;        if(X.dotNext != null){
         LDX     dotNext,x   ;            X = X.dotNext }
         BR      loopDe      ;    }
lineDe:  CPA     '-',i       ;    
         BRNE    outDecod    ;    if(signe == '-'){
         LDA     lineNext,x  ;
         CPA     0,i         ;
         BREQ    nopDecod    ;        if(X.lineNext != null){
         LDX     lineNext,x  ;            X = X.lineNext }
         BR      loopDe      ;    }
outDecod:LDA     0,i         ;
         LDBYTEA carac,x     ;    A = X.carac
         CPA     0,i         ;
         BRNE    Decode      ;    
nopDecod:STRO    nopDe,d     ;        afficher("nop")
         BR      endDecod    ;    }else{
Decode:  CHARO   carac,x     ;        afficher(X.carac)}
endDecod:CHARO   '\n',i      ;    afficher('\n')
         ret0                ;}
;
nopDe:   .ASCII "nop\x00"
;*****************************
;******* Methode translate
;*****************************
translt: LDX     begin,d     ; X = begin
         LDA     0,i         ;
         STA     nopTrs,d    ; nopTrs = 0
         STA     endTrs,d    ; endTrs = 0
loopTrs: LDA     0,i         ; while(signe != '\n'){
         CHARI   signe,d     ;    signe = lireChar
         LDBYTEA signe,d     ;
         CPA     '\n',i      ;
         BREQ    endTrans    ; 
         CPA     ' ',i       ;
         BREQ    outTrans    ;    if(signe != ' '){
         CPA     '.',i       ;        
         BRNE    lineTran    ;        if(signe == '.'){
         LDA     dotNext,x   ;    
         CPA     0,i         ;
         BREQ    nopTrans    ;            if(X.dotNext != 0){
         LDX     dotNext,x   ;                X = X.dotNext
lineTran:CPA     '-',i       ;            }
         BRNE    loopTrs     ;        }else if(signe == '-'){
         LDA     lineNext,x  ;
         CPA     0,i         ;
         BREQ    nopTrans    ;            if(X.lineNext != 0){
         LDX     lineNext,x  ;                X = X.lineNext }
         BR      loopTrs     ;}}
;Pour afficher '?'
nopTrans:LDA     1,i         ;
         STA     nopTrs,d    ; nopTrs = 1
         BR      loopTrs     ;
;Pour terminer la traduction
endTrans:LDA     1,i         ;
         STA     endTrs,d    ; endTrs = 1
;afficher la traduction
outTrans:LDA     0,i         ;
         LDBYTEA carac,x     ;
         CPA     0,i         ;
         BRNE    decodTrs    ; if(X.carac == 0){

rienTrs: STRO    nopTr,d     ;    print('?')
         BR      finiTrs     ;         
decodTrs:LDA     nopTrs,d    ;
         CPA     0,i         ;
         BRNE    rienTrs     ; }else{
         CHARO   carac,x     ;    print(X.carac)
                             ; }
finiTrs: LDA     endTrs,d    ;
         CPA     0,i         ;
         BREQ    translt     ; if(endTrs == 0){ Call translt() }
         CHARO   '\n',i      ; print('\n')    
         ret0                ; 

nopTr:   .ASCII "?\x00"      ;
endTrs:  .BLOCK  2           ;
nopTrs:  .BLOCK  2           ;
;*****************************
;******* Methode addRule
;*****************************
addRule: LDX     begin,d     ;X = begin
         CHARI   chara,d     ; chara = lireChar
loopRule:LDA     0,i         ; while(signe != '\n' && signe !=' '){
         CHARI   signe,d     ;    signe = lireChar
         LDBYTEA signe,d     ;
         CPA     '\n',i      ;
         BREQ    endRule     ;
         CPA     ' ',i       ;
         BREQ    endRule     ;
         
         CPA     '.',i       ;
         BRNE    goLine      ;    if(signe == '.'){
         LDA     dotNext,x   ;
         CPA     0,i         ;
         BRNE    dotRule     ;        if(X.dotNext != 0){
         LDA     mLength,i   ;
         CALL    new         ; X = new Maillon(); #carac #dotNext #lineNext #before
         LDA     0,i         ;
         STA     dotNext,x   ;            X.dotNext = 0
         STA     lineNext,x  ;            X.lineNext = 0
         STBYTEA carac,x     ;            X.carac = 0
         LDA     avant,d     ;     
         STA     before,x    ;            X.before = avant
         STX     head,d      ;            
         LDX     before,x    ;
         LDA     head,d      ;
         STA     dotNext,x   ;            X.dotNext = head
dotRule: LDA     dotNext,x   ;
         STA     avant,d     ;            avant = X.dotNext
         LDX     dotNext,x   ;
         BR      loopRule    ;        }

goLine:  CPA     '-',i       ;
         BRNE    endRule     ;    if(X.lineNext == '-'){        
         LDA     lineNext,x  ;
         CPA     0,i         ;
         BRNE    lineRule    ;        if(X.lineNext != 0){
         LDA     mLength,i
         CALL    new         ; X = new Maillon(); #carac #dotNext #lineNext #before
         LDA     0,i         ;
         STA     dotNext,x   ;            X.dotNext = 0
         STA     lineNext,x  ;            X.lineNext = 0
         STBYTEA carac,x     ;            X.carac = 0
         LDA     avant,d     ;
         STA     before,x    ;            X.before = avant
         STX     head,d      ;
         LDX     before,x    ;
         LDA     head,d      ;
         STA     lineNext,x  ;            X.lineNext = head
lineRule:LDA     lineNext,x  ;
         STA     avant,d     ;            avant = X.lineNext
         LDX     lineNext,x  ; 
         BR      loopRule    ;      }
                             ;}}//end while
endRule: LDA     0,i         ;
         LDBYTEA chara,d     ;
         STBYTEA carac,x     ; X.carac = chara
         ret0                ;
         
         
chara:   .BLOCK 1            ;
avant:   .BLOCK 2            ;

;*****************************
;******** Methode list
;*****************************
list:    LDX     begin,d
         LDA     0,i
         STA     total,d

listRec: SUBSP   4,i         ;#pDotNext #pLineNext 
         
         LDA     dotNext,x
         STA     pDotNext,s 
         LDA     lineNext,x
         STA     pLineNex,s        
         
         LDA     0,i
         LDBYTEA carac,x
         CPA     0,i
         BREQ    dotList
         CHARO   carac,x

         LDA     isCata,d
         CPA     1,i
         BRNE    saut
         CHARO   ' ',i
         LDA     0,i
         STA     compteur,d
         CALL    catalog        

saut:    CHARO   '\n',i 
         LDA     total,d
         ADDA    1,i
         STA     total,d 

dotList: LDA     pDotNext,s
         CPA     0,i
         BREQ    lineList
         LDX     pDotNext,s         
         CALL    listRec

lineList:LDA     pLineNex,s
         CPA     0,i
         BREQ    endList
         LDX     pLineNex,s
         CALL    listRec

endList: ret4                ;#pDotNext #pLineNext

;*****************************
;******** Methode catalogue
;***************************** 
catalog: LDA     before,x
         CPA     0,i
         BREQ    outCata
         SUBSP   2,i         ;#pileBefo
         STX     pileBefo,s
         LDA     compteur,d
         ADDA    1,i
         STA     compteur,d
         LDX     before,x
         BR      catalog 

outCata: LDX     begin,d
loopOut: LDA     compteur,d
         SUBA    1,i
         STA     compteur,d
         CPA     -1,i
         BREQ    endCata
         
         LDA     pileBefo,s
         CPA     dotNext,x
         BRNE    outLine
         CHARO   '.',i
         LDX     dotNext,x
         ADDSP   2,i         ;#pileBefo
         BR      loopOut
outLine: CPA     lineNext,x
         BRNE    loopOut
         CHARO   '-',i
         LDX     lineNext,x
         ADDSP   2,i         ;#pileBefo
         BR      loopOut 

endCata: ret0

isCata:  .BLOCK 2            ;#2d
compteur:.BLOCK 2            ;#2d

fin:     STOP                ; fin du programme
 
;******* Piles  
;*****************************
pileBefo:.EQUATE 0           ;#2h

pDotNext:.EQUATE 2           ;#2h 
pLineNex:.EQUATE 0           ;#2h   
;*****************************        
total:   .BLOCK  2           ;#2d
begin:   .BLOCK  2           ; #2h debut de liste
head:    .BLOCK  2           ; #2h tête de liste
signe:   .BLOCK  1           ; #1c
;
;******* structure du noeud
;*****************************
carac:   .EQUATE 0           ;#1c 
dotNext: .EQUATE 1           ;#2h
lineNext:.EQUATE 3           ;#2h
before:  .EQUATE 5           ;#2h
mLength: .EQUATE 7           ;taille d'un noeud
;******* operator new
; Precondition: A contains number of bytes
; Postcondition: X contains pointer to bytes
new:     LDX     hpPtr,d     ;returned pointer
         ADDA    hpPtr,d     ;allocate from heap
         STA     hpPtr,d     ;update hpPtr
         RET0                
hpPtr:   .ADDRSS heap        ;address of next free byte
heap:    .BLOCK  1           ;first byte in the heap
         .END                  
