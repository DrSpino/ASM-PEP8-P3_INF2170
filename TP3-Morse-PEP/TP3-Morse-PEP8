;******* Main
;*****************************
main:    CALL    init  
loop:    LDA     0,i         ;
         CHARI   command,d
         LDBYTEA command,d   ;
         CPA     'q',i       ;
         BRNE    decoder     ;
         CALL    fin         ;
decoder: CPA     'd',i       ;
         BRNE    traduire    ;
         CALL    decode      ;
traduire:CPA     't',i       ;
         BRNE    ajoute      ;
         ;call translate()
ajoute:  CPA     'a',i       ;
         BRNE    lister      ;
         ;call addRule()
lister:  CPA     'l',i       ;
         BRNE    cata        ;
         ;call lister()      ;
cata:    CPA     'c',i       ;
         BRNE    loop        ;
         ;call  catalog()    ;
         BR      loop        ;
          
command: .BLOCK 1            ;#1c       
;******** Initialisation 
;*****************************
init:    LDA     mLength,i   
         CALL    new         ;#carac #dotNext #lineNext #before
         LDA     0,i         
         LDBYTEA '0',i       
         STBYTEA carac,x     
         STX     begin,d     
         STX     head,d   
;  Noeud 'E' 
         LDA     mLength,i   
         CALL    new         ;#carac #dotNext #lineNext #before
         LDA     0,i         
         LDBYTEA 'E',i       
         STBYTEA carac,x     
         LDA     head,d      
         STA     before,x    
         STX     head,d      
         LDX     before,x    
         LDA     head,d      
         STA     dotNext,x   
;  Noeud '0'
         LDX     dotNext,x   
         LDA     mLength,i   
         CALL    new         ;#carac #dotNext #lineNext #before
         LDA     0,i         
         LDBYTEA '0',i       
         STBYTEA carac,x     
         LDA     head,d      
         STA     before,x    
         STX     head,d      
         LDX     before,x    
         LDA     head,d      
         STA     dotNext,x  
;  Noeud 'S'
         LDX     dotNext,x   
         LDA     mLength,i   
         CALL    new         ;#carac #dotNext #lineNext #before
         LDA     0,i         
         LDBYTEA 'S',i       
         STBYTEA carac,x     
         LDA     head,d      
         STA     before,x    
         STX     head,d      
         LDX     before,x    
         LDA     head,d      
         STA     dotNext,x  
 ; Noeud 'T'
         LDX     begin,d     
         LDA     mLength,i   
         CALL    new         ;#carac #dotNext #lineNext #before
         LDA     0,i         
         LDBYTEA 'T',i       
         STBYTEA carac,x     
         LDA     begin,d      
         STA     before,x    
         STX     head,d      
         LDX     before,x    
         LDA     head,d      
         STA     lineNext,x  
; Noeud '0'
         LDX     lineNext,x  
         LDA     mLength,i   
         CALL    new         ;#carac #dotNext #lineNext #before
         LDA     0,i         
         LDBYTEA '0',i       
         STBYTEA carac,x     
         LDA     head,d      
         STA     before,x    
         STX     head,d      
         LDX     before,x    
         LDA     head,d      
         STA     lineNext,x   
; Noeud 'O'
         LDX     lineNext,x  
         LDA     mLength,i   
         CALL    new         ;#carac #dotNext #lineNext #before
         LDA     0,i         
         LDBYTEA 'O',i       
         STBYTEA carac,x     
         LDA     head,d      
         STA     before,x    
         STX     head,d      
         LDX     before,x    
         LDA     head,d      
         STA     lineNext,x  
         ret0 
;***** Methode decode
;*****************************
decode:  LDX     begin,d     ; X = begin
loopDe:  LDA     0,i         ; while(signe != '\n'){
         CHARI   signe,d     ;    signe = lireChar
         LDBYTEA signe,d     ;
         CPA     '\n',i      ; 
         BREQ    outDecod    ;
         CPA     '.',i       ;    
         BRNE    lineDe      ;    if(signe == '.'){
         LDX     dotNext,x   ;        X = X.dotNext
         BR      loopDe      ;    }
lineDe:  CPA     '-',i       ;    
         BRNE    outDecod    ;    if(signe == '-'){
         LDX     lineNext,x  ;        X = X.lineNext
         BR      loopDe      ;    }
outDecod:LDA     0,i         ;
         LDBYTEA carac,x     ;    A = X.carac
         CPA     0,i         ;
         BRNE    nopDecod    ;    if(X.carac == null){
         STRO    nopDe,d     ;        afficher("nop") 
nopDecod:CPA     '0',i       ;    
         BRNE    Decode      ;    }else if(X.carac == '0'){
         STRO    nopDe,d     ;        afficher("nop")
         BR      endDecod    ;    }else{
Decode:  CHARO   carac,x     ;        afficher(X.carac)}
endDecod:CHARO   '\n',i      ;    afficher('\n')
         ret0                ;}
;
signe:   .BLOCK  1           ;#1c
nopDe:   .ASCII "nop\x00"
;*****************************
fin:     STOP        
;*****************************        
begin:   .BLOCK  2           ; #2h debut de liste
head:    .BLOCK  2           ; #2h tÃªte de liste
;
;****** structure du noeud
;*****************************
carac:   .EQUATE 0           ;#1c
dotNext: .EQUATE 1           ;#2h
lineNext:.EQUATE 3           ;#2h
before:  .EQUATE 5           ;#2h
mLength: .EQUATE 7           ;taille d'un noeud
;******* operator new
; Precondition: A contains number of bytes
; Postcondition: X contains pointer to bytes
new:     LDX     hpPtr,d     ;returned pointer
         ADDA    hpPtr,d     ;allocate from heap
         STA     hpPtr,d     ;update hpPtr
         RET0                
hpPtr:   .ADDRSS heap        ;address of next free byte
heap:    .BLOCK  1           ;first byte in the heap
         .END                  
